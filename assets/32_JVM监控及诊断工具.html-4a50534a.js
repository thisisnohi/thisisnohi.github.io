import{_ as a,p as e,q as i,a1 as l}from"./framework-449724a9.js";const n={},s=l(`<h1 id="_32-jvm监控及诊断工具" tabindex="-1"><a class="header-anchor" href="#_32-jvm监控及诊断工具" aria-hidden="true">#</a> 32_JVM监控及诊断工具</h1><h2 id="_01工具概述" tabindex="-1"><a class="header-anchor" href="#_01工具概述" aria-hidden="true">#</a> 01工具概述</h2><h3 id="jdk自带" tabindex="-1"><a class="header-anchor" href="#jdk自带" aria-hidden="true">#</a> JDK自带</h3><ul><li>jconsole</li><li>VisualVm</li><li>JMC</li></ul><h3 id="第三方工具" tabindex="-1"><a class="header-anchor" href="#第三方工具" aria-hidden="true">#</a> 第三方工具</h3><ul><li>MAT</li><li>JProfiler</li><li>Arthas</li><li>Btrace</li></ul><h2 id="_02-jconsole" tabindex="-1"><a class="header-anchor" href="#_02-jconsole" aria-hidden="true">#</a> 02 jconsole</h2><h2 id="_03-visualvm" tabindex="-1"><a class="header-anchor" href="#_03-visualvm" aria-hidden="true">#</a> 03 VisualVM</h2><ul><li>jvisualVM JDK1.6 自带 bin/jvisualVM</li><li>Visual VM 单独安装</li></ul><h2 id="_04-eclipse-mat" tabindex="-1"><a class="header-anchor" href="#_04-eclipse-mat" aria-hidden="true">#</a> 04 eclipse MAT</h2><p>MAT(Memory Analyzer Tool)</p><ul><li>所有对象信息：对象实例、成员变量、存储于栈中的基本类型值 和存储于堆中其他对象的引用值</li><li>所有的类信息，包括classloader、类名称、父类、静态变量</li><li>GCRoot到所有的对象的引用路径</li><li>线程信息，包括线程的调用栈及此线程的局部变量（TLS）</li></ul><h3 id="dump文件来源" tabindex="-1"><a class="header-anchor" href="#dump文件来源" aria-hidden="true">#</a> dump文件来源</h3><ul><li><p>jmap</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>jmap <span class="token operator">-</span>dump<span class="token operator">:</span>format<span class="token operator">=</span>b<span class="token punctuation">,</span>file<span class="token operator">=</span><span class="token generics"><span class="token punctuation">&lt;</span>filename<span class="token punctuation">.</span>hprof<span class="token punctuation">&gt;</span></span>  <span class="token constant">PID</span>
jmap <span class="token operator">-</span>dump<span class="token operator">:</span>live<span class="token punctuation">,</span>format<span class="token operator">=</span>b<span class="token punctuation">,</span>file<span class="token operator">=</span><span class="token generics"><span class="token punctuation">&lt;</span>filename<span class="token punctuation">.</span>hprof<span class="token punctuation">&gt;</span></span>  <span class="token constant">PID</span>  堆中存活对象
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>通过配置JVM参数生成</p><ul><li><p>-XX:+HeapDumpOnOutOfMemoryError</p></li><li><p>-XX:+HeapDumpBeforeFullGC</p></li><li><p>-XX:HeapDumpPath=&lt;filename.hprof&gt;</p></li></ul></li><li><p>VisualVM可以导出dump文件</p></li><li><p>MAT即可以打开一个已有的堆快照，也可以直接从活动的Java程序中导出堆快照</p></li></ul><h3 id="分析" tabindex="-1"><a class="header-anchor" href="#分析" aria-hidden="true">#</a> 分析</h3><ul><li><p>Hitogram 显示类实例数目及实例的heap和retaninedheap总和</p></li><li><p>thread overview: 查看系统java线程、局部变量的信息</p></li><li><p>深堆、浅堆</p><ul><li><p>浅堆：指一个对象所消耗的内存</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>以String为例：2个int值共占8字节，对象引用占用4字节，对象头8字节，合计20字节，向8字节对齐，故占24字节
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>保留集</p><p>对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合（包括A本身），即对象A的保留集可以被认为是<code>只能通过</code>对象A被直接或间接访问到的所有对象的集合。通俗地说，就是指仅被对象A所持有的对象集合</p></li><li><p>深堆</p><p>深堆是指对象的保留集中所有的对象的浅堆大小之和</p></li></ul></li></ul><h2 id="_05-内存泄漏" tabindex="-1"><a class="header-anchor" href="#_05-内存泄漏" aria-hidden="true">#</a> 05 内存泄漏</h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><ul><li>何为内存泄漏：在被使用，但不是需要的 <ul><li>对象不在被程程序用到，但GC又不能回收他们的情况</li></ul></li></ul><h3 id="java内存泄漏的情况" tabindex="-1"><a class="header-anchor" href="#java内存泄漏的情况" aria-hidden="true">#</a> java内存泄漏的情况</h3><ul><li>静态集合类</li><li>单例模式</li><li>内部类持有外部类</li><li>各种连接，如数据库连接、网络连接和IO</li><li>变量不合理的作用域</li><li>改变哈希值</li><li>缓存泄漏</li><li>监听器和回调</li></ul><h2 id="_06-oql" tabindex="-1"><a class="header-anchor" href="#_06-oql" aria-hidden="true">#</a> 06 OQL</h2><h3 id="select" tabindex="-1"><a class="header-anchor" href="#select" aria-hidden="true">#</a> SELECT</h3><ul><li>select * from java.util.Vector v</li><li>正则：select * from &quot;nohi\\.online\\..*&quot;</li></ul><h2 id="_07-arthas" tabindex="-1"><a class="header-anchor" href="#_07-arthas" aria-hidden="true">#</a> 07 Arthas</h2><blockquote><p>官方文档：https://arthas.aliyun.com/</p></blockquote><ul><li><p>Web-console: http://127.0.0.1:8563</p></li><li><p>常用命令</p><ul><li><p>dashboard</p></li><li><p>thread</p></li><li><p>sysprop</p></li><li><p>heapdump</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>heapdump --live
heapdump /tmp/dump.hprof
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>sc class</p></li><li><p>Sm 方法</p></li><li><p>jad 反编译</p></li><li><p>mc、redefine</p></li><li><p>classload</p></li></ul></li></ul><h2 id="jmc" tabindex="-1"><a class="header-anchor" href="#jmc" aria-hidden="true">#</a> JMC</h2><p>优点：采用取样，不是采用传统的代码植入技术，对应用性能的影响较小，完成可以开着JMC来做压测。</p>`,29),r=[s];function p(t,d){return e(),i("div",null,r)}const c=a(n,[["render",p],["__file","32_JVM监控及诊断工具.html.vue"]]);export{c as default};
