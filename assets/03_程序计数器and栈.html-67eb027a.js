import{_ as l,p as i,q as e,a1 as a}from"./framework-449724a9.js";const r={},t=a('<h1 id="_03-程序计数器" tabindex="-1"><a class="header-anchor" href="#_03-程序计数器" aria-hidden="true">#</a> 03 程序计数器</h1><ul><li>为什么需要程序计数器 <ul><li>线程级的</li><li>程序序计数器，保存的是线程正在执行的字节码地址、行号</li><li>多线程情况下，线程间切换确保线程正常执行</li></ul></li></ul><h2 id="_04栈" tabindex="-1"><a class="header-anchor" href="#_04栈" aria-hidden="true">#</a> 04栈</h2><ul><li><p>内容：</p><ul><li>局部变量表：一个栈帧对应一个方法，那每个方法里有变量，没毛病~</li><li>操作数栈：方法里如果有运算操作的话，这个就是暂时存储局部变量的值的临时空间了~</li><li>方法出口：见名知意，方法里面调方法，里面的方法执行完了，总得知道回到哪里去执行吧~</li><li>动态链接：在运行时，把符号链接转换为直接链接，就是把每个对象的所在包地址换成内存空间的地址~</li></ul></li><li><p>特点：</p><ul><li>线程级，生命周期同线程生命周期</li><li>无GC，存在OOM、StackOverflowError <ul><li>线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</li><li>不停的创建线程，就会抛出OutOfMemoryError</li></ul></li></ul></li><li><p>设置大小： -Xss，windows不定，其他默认1024KB</p></li><li><p>实现</p><ul><li>数组、链表</li></ul></li><li><p>早期绑定、晚期绑定</p><ul><li>编译时绑定的方法为早期绑定</li><li>运行时动态绑定，为晚期绑定（由于多态、继承而出现）</li></ul></li><li><p>非虚方法</p><ul><li>静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法</li><li>其他为<code>虚方法</code></li></ul></li></ul><h2 id="_7-本地方法栈" tabindex="-1"><a class="header-anchor" href="#_7-本地方法栈" aria-hidden="true">#</a> 7 本地方法栈</h2><ul><li><p>本地方法：native</p><p>Object: public final native Class&lt;?&gt; getClass();</p></li></ul>',6),_=[t];function u(n,c){return i(),e("div",null,_)}const o=l(r,[["render",u],["__file","03_程序计数器and栈.html.vue"]]);export{o as default};
