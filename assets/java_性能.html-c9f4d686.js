import{_ as e,p as a,q as i,a1 as l}from"./framework-449724a9.js";const r={},n=l(`<h1 id="性能" tabindex="-1"><a class="header-anchor" href="#性能" aria-hidden="true">#</a> 性能</h1><blockquote><p>20190130 https://www.ibm.com/developerworks/cn/java/j-lo-performance-tuning-practice/index.html</p></blockquote><h2 id="常规" tabindex="-1"><a class="header-anchor" href="#常规" aria-hidden="true">#</a> 常规</h2><ul><li>JVM<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>-Xmx   Java Heap最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定
-Xms   Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；

-Xmn   Java Heap Young区大小，不熟悉最好保留默认值；

-Xss   每个线程的Stack大小，不熟悉最好保留默认值；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>### 查看线程、进程
* top -Hp pid 查看进程下线程信息(mac： ps -M pid查看线程信息)
  查看到耗时的线程
* printf &quot;%x\\n&quot; threadid 得到十六进制串
* jstack -l pid 查看堆栈信息
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>jdk8</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>https://blog.csdn.net/vivisran/article/details/103060508
java -XX:+PrintFlagsFinal -version | grep MetaspaceSize查看metaspacesize
fullgc:
	-Xms4096m -Xmx4096m -XX:MetaspaceSize=512m -XX:MaxMetaspaceSize=512m
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="java-应用诊断工具" tabindex="-1"><a class="header-anchor" href="#java-应用诊断工具" aria-hidden="true">#</a> Java 应用诊断工具</h2><h3 id="jps" tabindex="-1"><a class="header-anchor" href="#jps" aria-hidden="true">#</a> JPS</h3><blockquote><p>查看进程信息</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&gt; jps -m -l
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="jmap" tabindex="-1"><a class="header-anchor" href="#jmap" aria-hidden="true">#</a> jmap</h3><blockquote><p>可以生成 java 程序的 dump 文件， 也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列</p></blockquote><ul><li><p>jmap -dump:format=b,file=dumpFileName pid 内存使用情况dump到文件中</p><p>jmap -dump:format=b,file=/tmp/dump.dat 21711</p></li><li><p>生成快照：jmap -dump:format=b,file=heapdump.phrof pid</p></li><li><p>jmap -heap pid:查看堆使用情况</p></li><li><p>jmap -histo pid：查看堆中对象数量和大小</p></li></ul><h3 id="jstat-gcutil-332-1000" tabindex="-1"><a class="header-anchor" href="#jstat-gcutil-332-1000" aria-hidden="true">#</a> jstat -gcutil 332 1000</h3><ul><li>jstat -gcutil pid 1000(轮循时间间隔)</li></ul><h3 id="jstack" tabindex="-1"><a class="header-anchor" href="#jstack" aria-hidden="true">#</a> jstack</h3><p>jstack是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出 Java 应用程序中线程堆栈信息。</p><ul><li>top -H -p pid 定位 Java 进程和线程</li><li>mac： ps -M pid查看线程信息</li><li>jstack -l pid 导出线程栈</li></ul><h3 id="jconsole" tabindex="-1"><a class="header-anchor" href="#jconsole" aria-hidden="true">#</a> Jconsole</h3><ul><li>启动命令增加：-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=12345 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=192.168.0.194&quot;</li><li>本机启动jconsole</li></ul><h3 id="jinfo" tabindex="-1"><a class="header-anchor" href="#jinfo" aria-hidden="true">#</a> jinfo</h3><blockquote><p>jinfo可以用来查看正在运行的java运用程序的扩展参数，甚至支持在运行时动态地更改部分参数</p></blockquote><ul><li><p>jinfo pid</p></li><li><p>-flag&lt; name &gt;: 打印指定java虚拟机的参数值</p><p>-flag [+|-]&lt; name &gt;：设置或取消指定java虚拟机参数的布尔值</p><p>-flag &lt; name &gt;=&lt; value &gt;：设置指定java虚拟机的参数的值</p></li></ul><h3 id="jcmd" tabindex="-1"><a class="header-anchor" href="#jcmd" aria-hidden="true">#</a> jcmd</h3><blockquote><p>在JDK 1.7之后，新增了一个命令行工具jcmd。它是一个多功能工具，可以用来导出堆，查看java进程，导出线程信息，执行GC等。jcmd拥有jmap的大部分功能，Oracle官方建议使用jcmd代替jmap。</p></blockquote><ul><li>jcmd -l 列出当前运行的所有虚拟机</li><li>jcmd pid help 列出该虚拟机支持的所有命令</li><li>jcmd pid VM.command_line</li></ul><h3 id="jprofiler" tabindex="-1"><a class="header-anchor" href="#jprofiler" aria-hidden="true">#</a> JProfiler</h3><blockquote><p>https://www.cnblogs.com/AmilyWilly/p/7272160.html?utm_source=itdadao&amp;utm_medium=referral 建议安装 9.2.1 ，安装10 idea中出现license 失效问题。</p></blockquote><p>L-Larry_Lau@163.com#40775-3wle0g1uin5c1#0674</p><h4 id="jprofiler9-linux-was" tabindex="-1"><a class="header-anchor" href="#jprofiler9-linux-was" aria-hidden="true">#</a> jprofiler9 + linux + was</h4><blockquote><p>服务器安装，不需要启动。</p></blockquote><ul><li><p>客户端(windows)</p></li><li><p>start center -&gt; new seession -&gt; new server integration</p></li><li><p>选择容器(was) ....</p></li><li><p>Remote installation directory 服务器jprofiler安装目录</p></li><li><p>config synchronization 选择 manual synchronization(手工同步)</p><ul><li>配置目录输入一个目录，需要把客户端的config文件同步过去。</li><li>客户端config.xml C:\\Users\\用户名(因人不而异).jprofiler9\\config.xml</li></ul></li><li><p>Locate the config file。需要拷贝was服务器的server.xml至本地目录。</p><ul><li>/opt/IBM/WebSphere/AppServer/profiles/AppSrv01/config/cells/appNode01Cell/nodes/appNode01/servers/server1/server.xml</li></ul></li><li><p>最后一步： 选择稍后启动。</p></li><li><p>第一次会连接失败，需要将本地目录server.xml拷贝到WebSphere的server.xml配置文件的位置，然后覆盖之（覆盖之前备份一下）</p></li><li><p>启动was</p></li><li><p>本地连接</p></li></ul><h3 id="mat-memory-analyzer-tool" tabindex="-1"><a class="header-anchor" href="#mat-memory-analyzer-tool" aria-hidden="true">#</a> MAT (Memory Analyzer tool)</h3><blockquote><p>参考：https://cloud.tencent.com/developer/article/1379028</p></blockquote><p>在线分析：https://fastthread.io/</p><h3 id="async-profiler" tabindex="-1"><a class="header-anchor" href="#async-profiler" aria-hidden="true">#</a> async-profiler</h3><blockquote><p>https://github.com/jvm-profiling-tools/async-profiler</p></blockquote><ul><li>./profiler.sh -d 30 -f ./aaa.svg 2488</li></ul>`,38),t=[n];function d(s,o){return a(),i("div",null,t)}const p=e(r,[["render",d],["__file","java_性能.html.vue"]]);export{p as default};
