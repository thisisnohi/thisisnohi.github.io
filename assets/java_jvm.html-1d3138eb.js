import{_ as t,p as d,q as e,a1 as r}from"./framework-449724a9.js";const a={},l=r('<h1 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm" aria-hidden="true">#</a> JVM</h1><h2 id="参数" tabindex="-1"><a class="header-anchor" href="#参数" aria-hidden="true">#</a> 参数</h2><blockquote><p>参考：https://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html</p></blockquote><table><thead><tr><th style="text-align:left;">参数名称</th><th>参数</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left;">-Xms</td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td style="text-align:left;">-Xmx</td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td style="text-align:left;">-Xmn</td><td>年轻代大小(1.4or lator)</td><td></td><td><strong>注意</strong>：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。<br>整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.<br>增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td style="text-align:left;">-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td style="text-align:left;">-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td style="text-align:left;">-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td></td></tr><tr><td style="text-align:left;">-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4</td><td></td></tr><tr><td style="text-align:left;">-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右<br>一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）<br>和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:&quot;”<br>-Xss is translated in a VM flag named ThreadStackSize”<br>一般设置这个值就可以了。</td></tr><tr><td style="text-align:left;">-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td></td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td style="text-align:left;"></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>-XX:+PrintGC</th><th></th><th></th><th>输出形式:[GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</th></tr></thead><tbody><tr><td>-XX:+PrintGCDetails</td><td></td><td></td><td>输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td></td><td></td><td></td></tr><tr><td>-XX:+PrintGC:PrintGCTimeStamps</td><td></td><td></td><td>可与-XX:+PrintGC -XX:+PrintGCDetails混合使用 输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</td></tr><tr><td>-XX:+PrintGCApplicationStoppedTime</td><td>打印垃圾回收期间程序暂停的时间.可与上面混合使用</td><td></td><td>输出形式:Total time for which application threads were stopped: 0.0468229 seconds</td></tr><tr><td>-XX:+PrintGCApplicationConcurrentTime</td><td>打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用</td><td></td><td>输出形式:Application time: 0.5291524 seconds</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td>打印GC前后的详细堆栈信息</td><td></td><td></td></tr><tr><td>-Xloggc:filename</td><td>把相关日志信息记录到文件以便分析. 与上面几个配合使用</td><td></td><td></td></tr><tr><td>-XX:+PrintClassHistogram</td><td>garbage collects before printing the histogram.</td><td></td><td></td></tr><tr><td>-XX:+PrintTLAB</td><td>查看TLAB空间的使用情况</td><td></td><td></td></tr><tr><td>XX:+PrintTenuringDistribution</td><td>查看每次minor GC后新的存活周期的阈值</td><td></td><td>Desired survivor size 1048576 bytes, new threshold 7 (max 15) new threshold 7即标识新的存活周期的阈值为7。</td></tr></tbody></table><ul><li>-XX:+PrintGCDetails</li><li>初始堆</li><li>-Xmx 最大堆</li><li>-XX:PermSize 设置持久代(perm gen)初始值 默认</li><li>-Xmn 新生代</li></ul><p>https://blog.csdn.net/vivisran/article/details/103060508</p><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">GC</th><th style="text-align:center;">ERROR</th></tr></thead><tbody><tr><td style="text-align:center;">程序计数器</td><td style="text-align:center;">无</td><td style="text-align:center;">无</td></tr><tr><td style="text-align:center;">栈</td><td style="text-align:center;">无</td><td style="text-align:center;">StackOverflowError</td></tr><tr><td style="text-align:center;">本地方法栈</td><td style="text-align:center;">无</td><td style="text-align:center;">StackOverflowError</td></tr><tr><td style="text-align:center;">堆</td><td style="text-align:center;">GC</td><td style="text-align:center;">OOM</td></tr><tr><td style="text-align:center;">无空间</td><td style="text-align:center;">GC</td><td style="text-align:center;">OOM</td></tr></tbody></table><h2 id="xx-x-区别" tabindex="-1"><a class="header-anchor" href="#xx-x-区别" aria-hidden="true">#</a> -XX -X 区别</h2><table><thead><tr><th>配置 参数</th><th>类型</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>-X</td><td>non-standard</td><td>非标准参数。这些参数不是虚拟机规范规定的。因此，不是所有VM的实现(如:HotSpot,JRockit,J9等)都支持这些配置参数。</td><td>-Xmx、-Xms、-Xmn、-Xss</td></tr><tr><td>-XX</td><td>not-stable</td><td>不稳定参数。这些参数是虚拟机规范中规定的。这些参数指定虚拟机实例在运行时的各种行为，从而对虚拟机的运行时性能有很大影响。</td><td>-XX:MetaspaceSize=1g<br>-XX:SurvivorRatio<br>-XX:+UseParNewGc</td></tr></tbody></table>',10),i=[l];function n(s,o){return d(),e("div",null,i)}const c=t(a,[["render",n],["__file","java_jvm.html.vue"]]);export{c as default};
