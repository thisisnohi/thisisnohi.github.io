import{_ as a}from"./image-20221126191054010-bc2a5ba1.js";import{_ as r,M as p,p as n,q as t,R as l,N as s,U as o,t as u,a1 as i}from"./framework-449724a9.js";const C="/assets/image-20221128123908040-89fa083c.png",c="/assets/21669612816_.pic-7c4ea01d.jpg",d="/assets/31669613013_.pic-57923d25.jpg",G={},h=i('<h1 id="_13-垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_13-垃圾回收器" aria-hidden="true">#</a> 13 垃圾回收器</h1><ol><li>GC分类与性能指标</li><li>不同的垃圾回收器概述</li><li>Serial回收器：串行回收</li><li>ParNew回收：并行回收</li><li>Paralle回收：吞吐量优先</li><li>CMS回收器：低延迟</li><li>G1回收器：区域化分代式</li><li>垃圾回收器总结</li><li>GC日志分析</li><li>垃圾回收器的新发展</li></ol><h2 id="_1-gc分类与性能指标" tabindex="-1"><a class="header-anchor" href="#_1-gc分类与性能指标" aria-hidden="true">#</a> 1 GC分类与性能指标</h2>',3),_=i("<li><p>分类</p><ul><li>按线程数：并行、串行 <ul><li>串行默认被应用于客户端Client模式下使用</li></ul></li><li>按工作模式：并发式、独占式 <ul><li>并发：垃圾回收与应用程序交替执行</li></ul></li><li>按碎片处理方式：压缩式、非压缩式 <ul><li>压缩：指针碰撞</li><li>非压缩式：空闲列表</li></ul></li><li>按工作区间：年轻代、老年代</li></ul></li>",1),X=l("p",null,"性能指标",-1),S=l("li",null,[l("p",null,"吞吐量：运行用户代码的时间占总运行时间的比例")],-1),g=l("li",null,[l("p",null,"暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间")],-1),P=l("li",null,[l("p",null,"内存占用：Java堆区所占的内存大小")],-1),m=l("li",null,[l("p",null,"收集频率：相对于应用程序的执行，收集操作发生的频率")],-1),M=l("li",null,[l("p",null,"垃圾收集开销")],-1),f=l("li",null,[l("p",null,"快速：一个对象从诞生到被回收所经历的时间")],-1),x=l("p",null,"在最大吞吐量优先的情况下，降低停顿时间",-1),U=i('<h2 id="_2不同的垃圾回收器概述" tabindex="-1"><a class="header-anchor" href="#_2不同的垃圾回收器概述" aria-hidden="true">#</a> 2不同的垃圾回收器概述</h2><blockquote><p>Java常见的垃圾收集器有哪些？</p></blockquote><ul><li><p>1999 jdk1.3.1 串行SerialGC，第一款GC。ParNew是SerialGC的并行版本</p></li><li><p>2022.2.26 Parallel Gc、Concurrent Mark Sweep GC（CMS） 随jdk1.4.2一起发布</p></li><li><p>Parallel GC 在JDK6之后成为HotSpot默认GC</p></li><li><p>2012 jdk1.7 G1可用 （新生代、老年化）</p></li><li><p>2017 jdk9 G1为默认垃圾收集器，以替代CMS</p></li><li><p>2018年3月 jdk10 G1 垃圾回收器的并行完成垃圾回收，实现并行 来改善最坏情况下的延迟</p><hr></li><li><p>2018年9月 jdk11 引入Epsilon垃圾回收器，又被称为“No-Op”（无操作）回收器。同时引入ZGC，可伸缩的低延迟垃圾回收器（Experimental，实验性)</p></li><li><p>2019年3月，JDK12发布，增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah Gc：低停顿时间的GC（Experimental，实验性)</p></li><li><p>2019年9月 JDK13发布。增强ZGC，自动返回未用堆内存给操作系统</p></li><li><p>2020年3月 JDK14发布。删除CMS垃圾回收器，扩展ZGC在MacOS和Windows上的应用</p></li></ul><p><strong>7款经典的垃圾收集器</strong></p><p>​ 串行回收器：Serial、Serial Old</p><p>​ 并行回收器：Parnew、Parallel Scavenge、Parallel Old</p><p>​ 并发回收器：CMS、G1</p><p>新生代收集器: Serial GC Parallel Scavenge、ParNew GC</p><p>老年代收集器: Serial Old、Parallel Old、CMS</p><p>整堆： G1</p><img src="'+a+'" alt="image-20221126191054010" style="zoom:67%;"><ul><li>如何查看使用的垃圾回收器 <ul><li>-XX:+PrintCommandLineFlags</li><li>jinfo -flag UseG1GC/UseParallelGC pid</li><li>JDK6之后默认Parallel GC</li><li>JDK9后默认G1</li></ul></li></ul><h2 id="_3-serial回收器-串行回收" tabindex="-1"><a class="header-anchor" href="#_3-serial回收器-串行回收" aria-hidden="true">#</a> 3 Serial回收器-串行回收</h2><p>+XX:+UserSerialGC 新生代用不用 Serial GC,老年代使用Serial Old GC</p><ul><li>优势: 简单高效，尤其单CPU时，减少CPU切换消耗</li><li>目前较少使用，在多核CPU时，效率不高</li></ul><h2 id="_4-parnew回收器-并行回收" tabindex="-1"><a class="header-anchor" href="#_4-parnew回收器-并行回收" aria-hidden="true">#</a> 4 ParNew回收器-并行回收</h2><p>-XX:+UseParNewGC 指定ParNew GC</p><p>-XX:ParallelGCThreads 限制线程数量，默认开启和CPU核数相同的线程数</p><h2 id="_5-parallel-scavenge回收器-吞吐量优先" tabindex="-1"><a class="header-anchor" href="#_5-parallel-scavenge回收器-吞吐量优先" aria-hidden="true">#</a> 5 Parallel Scavenge回收器-吞吐量优先</h2><p>回收新生代，复制算法、并行回收、STW</p><p>Parallel Old 标记-压缩</p><p>可控制吞吐量、吞吐量优先，适合在后台运算、不需要太多交互的任务</p><ul><li>场景：批量处理、订单处理、工资支付、科学计算</li><li>jdk1.6 替换Serial Old GC做为老年代GC</li><li>-XX:+UseParallelGC -XX:+UseParallelOldGC <ul><li>开启一个，另一个也会开启</li></ul></li><li>-XX:ParallelGCThreads 限制线程数量，默认开启和CPU核数相同的线程数</li><li>-XX:MaxGCPauseMills 垃圾收集器最大停顿时间</li><li>-XX:GCTimeRatio 垃圾收集时间占总时间的比例(0,100) 默认99，即垃圾回收不超过1%</li></ul><h2 id="_6-cms回收器-低延迟" tabindex="-1"><a class="header-anchor" href="#_6-cms回收器-低延迟" aria-hidden="true">#</a> 6 CMS回收器-低延迟</h2><p>JDK1.5 推出 Concurrent-Mark-Sweep 标记清除，垃圾回收线程也用户线程同时工作</p><ul><li>初始标记：STW，标记GC Roots能直接关联到的对象，速度非常快</li><li>并发标记(Conrurrent-Mark)：从GC Roots直接关联对象开始遍历整个对象图的对过，耗时较长但不需STW。</li><li>重新标记(Remark)阶段：修改并发标记期间，因程序运行产生变动的部分对象进行标记记录。</li><li>并发清除(concurrent-Sweep)：清理标记阶段判断已经死亡的对象，释放空间。<strong>存放碎片</strong></li></ul><hr><ul><li>优点： <ul><li>并发收集</li><li>低延迟</li></ul></li><li>弊端： <ul><li>产生内存碎片</li><li>CMS收集器CPU资源非常敏感</li><li>CMS收集器无法处理浮动垃圾</li></ul></li><li>参数： <ul><li>-XX:+UseConcMarkSweepGC 指定使用CMS GC （老年代） <ul><li>开启后自动启动-XX:UseParNewGC，指定新生代GC</li></ul></li><li>-XX:CMSlnitiatingOccupanyFraction 设置堆内存使用率的阈值</li><li>-XX:+UseCMSCompactAtFullCollection 指定Full GC 进行压缩整理，避免碎片</li><li>-XX:CMSFullGCsBeforeCompaction 设置执行多少次Full GC后对内在空间进行压缩</li><li>-XX:ParalleCMSThreads 设置CMS的线程数量</li></ul></li><li>小结 <ul><li>最小化使用内在和并行开销：Serial GC</li><li>最大化程序的吞吐量： Parllel GC</li><li>最小化GC中断或停顿时间： CMS GC (ParNew GC 做新生代)</li><li>JDK9 CMS 标识为Deprecate</li></ul></li></ul><h2 id="_7-g1回收器-区域化分代式" tabindex="-1"><a class="header-anchor" href="#_7-g1回收器-区域化分代式" aria-hidden="true">#</a> 7 G1回收器-区域化分代式</h2><p>G1: Garbage First -XX:+UseG1GC</p><p>延迟可控的情况下，获得尽可能高的吞吐量，全功能收集器</p><ul><li><p>并行与并发</p><ul><li>并行性：G1在回收期间，多个GC线程同时工作</li><li>并发性：G1拥有与应用程序交替执行能力，部分工作可以和应用程序交替执行</li></ul></li><li><p>分代收集</p><ul><li>区分年轻代、老年代</li></ul></li><li><p>空间整合</p></li><li><p>可预测的停顿时间模型</p></li><li><p>参数</p><ul><li>-XX:+UseG1GC</li><li>-XX:G1HeapRegionSize 设置每个Region的大小，值是2的幂，范围1MB-32MB，默认是堆内存1/2000</li><li>-XX:MaxGCPauseMills 期望达到的最大GC停顿时间指标（但不保证达到），默认200ms</li><li>-XX:ParallelGCThread STW工作线程数，最多8</li><li>-XX:ConcGCThreads 并发标记的线程数，设置为并行 垃圾回收纯种的1/4左右</li><li>-XX:InitiatingHeapOccupancyPercent 触发并发GC周期的Java堆占用率阈值，默认45% ？？？</li></ul></li><li><p>场景：</p><ul><li>面向服务端，大内存、多处理器</li><li>最主要的应用是低GC延迟，</li><li>如堆大小6GB或更大时，可预测的暂停时间可以低于0.5s</li><li>用来替换JDK1.5中的CMS收集器</li></ul></li><li><p>分区Region 化整为零</p><ul><li>H 堆中大对象，默认直接会被分配到老年代，如果是一个短期存在的大对象，就会对垃圾收集造成影响。G1划分了Humongous区存储。</li></ul></li><li><p>G1回收过程</p><ul><li>年轻代GC （Young GC) <ul><li>RSet</li></ul></li><li>老年代并发过程（Concurrent Marking)</li><li>混合回收（Mixed GC)</li></ul></li></ul><h2 id="_8-7种经典垃圾回收器总结" tabindex="-1"><a class="header-anchor" href="#_8-7种经典垃圾回收器总结" aria-hidden="true">#</a> 8 7种经典垃圾回收器总结</h2><img src="'+C+'" alt="image-20221128123908040" style="zoom:67%;"><p>Serial =&gt; Parallel =&gt; CMS =&gt; G1 =&gt; ZGC</p><h2 id="_9-如何选择垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_9-如何选择垃圾回收器" aria-hidden="true">#</a> 9 如何选择垃圾回收器</h2><ul><li><p>优先调整堆的大小让JVM自适应完成</p></li><li><p>如果内存小于100M，使用串行收集器</p></li><li><p>如果是单核、单机程序、没有停顿时间要求，串行</p></li><li><p>如果是多CPU、需要吞吐量、允许停顿时间超过1S，选择并行或者JVM自已选择</p></li><li><p>如果是多CPU、所示低停顿时间，需要快速响应（比如延迟不能超过1S，如互联网应用）使用并行收集器</p><p>官方推荐G1</p><p>没有最好的收集器，更没有万能的收集器</p><p>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</p></li></ul><h2 id="_10-gc日志" tabindex="-1"><a class="header-anchor" href="#_10-gc日志" aria-hidden="true">#</a> 10 GC日志</h2><ul><li><p>参数</p><ul><li>-XX:+PrintGC 输出GC日志，类似：-verbose:gc</li><li>-XX:+PrintGCDetails 转出GC详细日志</li><li>-XX:+PrintGCTimeStamps 输出GC的时间戳(以基准时间的形式) <ul><li>JDK11后：-Xlog:gc::utctime -XX:NativeMemoryTracking=summary</li></ul></li><li>-XX:+PrintGCDateStamps 输出GC的时间戳(以日期的形式，如：2022-11-28T13:01:03.123+0800)</li><li>-XX:PrintHeapAtGC 在进行GC的前后打印出堆的信息</li><li>-Xloggc:../logs/gc.log 日志文件输出路径</li></ul></li><li><p>Young GC</p></li></ul><img src="'+c+'" alt="21669612816_.pic.jpg" style="zoom:67%;"><ul><li>Full GC</li></ul><img src="'+d+'" alt="31669613013_.pic.jpg" style="zoom:67%;">',42);function k(w,b){const e=p("font");return n(),t("div",null,[h,l("ul",null,[_,l("li",null,[X,l("ul",null,[S,g,P,m,M,f,l("li",null,[s(e,{color:"red"},{default:o(()=>[u("重点关注： 吞吐量、暂停时间")]),_:1}),x])])])]),U])}const T=r(G,[["render",k],["__file","13_垃圾回收器.html.vue"]]);export{T as default};
