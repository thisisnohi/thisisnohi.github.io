import{_ as n,M as i,p as r,q as t,R as e,t as a,N as l,a1 as d}from"./framework-449724a9.js";const c={},p=e("h1",{id:"证书密钥",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#证书密钥","aria-hidden":"true"},"#"),a(" 证书密钥")],-1),o=e("h2",{id:"证书",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#证书","aria-hidden":"true"},"#"),a(" 证书")],-1),u={href:"https://www.cnblogs.com/ljhdo/p/14109218.html",target:"_blank",rel:"noopener noreferrer"},v=d(`<h3 id="文件形式存在的证书一般有三种格式" tabindex="-1"><a class="header-anchor" href="#文件形式存在的证书一般有三种格式" aria-hidden="true">#</a> 文件形式存在的证书一般有三种格式：</h3><ul><li>第一种：带有私钥的证书，由Public Key Cryptography Standards #12，PKCS#12标准定义，包含了公钥和私钥的二进制格式的证书形式，以.pfx作为证书文件后缀名。</li><li>第二种：<strong>DER Encoded Binary (.cer)</strong> 二进制编码的证书，证书中没有私钥，DER 编码二进制格式的证书文件，以.cer作为证书文件后缀名。</li><li>第三种：<strong>Base64 Encoded(.cer)</strong>，Base64编码的证书，证书中没有私钥，BASE64 编码格式的证书文件，也是以.cer作为证书文件后缀名。</li></ul><h3 id="pfx、cer转pem及提取公钥、私钥" tabindex="-1"><a class="header-anchor" href="#pfx、cer转pem及提取公钥、私钥" aria-hidden="true">#</a> pfx、cer转pem及提取公钥、私钥</h3><blockquote><p>https://www.jianshu.com/p/bc18038cc9c8</p></blockquote><p>1、将xxx.cer和xxxpfx文件转换成xxx.pem格式的文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>openssl pkcs12 <span class="token parameter variable">-in</span> <span class="token number">503</span>.pfx <span class="token parameter variable">-nodes</span> <span class="token parameter variable">-out</span> 503_42.pem
openssl x509 <span class="token parameter variable">-inform</span> der <span class="token parameter variable">-in</span> xxx.cer <span class="token parameter variable">-out</span> xxx.pem
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2、从xxx.pfx中提取密钥对</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>openssl pkcs12 <span class="token parameter variable">-in</span> <span class="token number">503</span>.pfx <span class="token parameter variable">-nocerts</span> <span class="token parameter variable">-nodes</span> <span class="token parameter variable">-out</span> private_pc.key
需要输入密码: jsccb188
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>3、从密钥对中提取私钥(头部格式：-----BEGIN RSA PUBLIC KEY-----）</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>openssl rsa <span class="token parameter variable">-in</span>  private_pc.key <span class="token parameter variable">-out</span> private.pem
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>4、从密钥对提取公钥(头部格式：-----BEGIN RSA PRIVATE KEY-----）</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>openssl rsa <span class="token parameter variable">-in</span> private.pem <span class="token parameter variable">-RSAPublicKey_out</span> <span class="token parameter variable">-out</span> public.pem
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>5、从密钥对提取公钥(头部格式：-----BEGIN PUBLIC KEY-----）</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>openssl rsa <span class="token parameter variable">-in</span> private_pc.key <span class="token parameter variable">-pubout</span> <span class="token parameter variable">-out</span> public.key
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="pkcs1-pkcs8-主要java用" tabindex="-1"><a class="header-anchor" href="#pkcs1-pkcs8-主要java用" aria-hidden="true">#</a> pkcs1 -&gt; pkcs8 （主要Java用）</h2><blockquote><p>private.pem/public.pem pkcs1</p></blockquote><ul><li>openssl pkcs8 -topk8 -inform PEM -in private.pem -outform PEM -out private_pkcs8.pem -nocrypt</li></ul><h2 id="密钥" tabindex="-1"><a class="header-anchor" href="#密钥" aria-hidden="true">#</a> 密钥</h2><h3 id="格式" tabindex="-1"><a class="header-anchor" href="#格式" aria-hidden="true">#</a> 格式</h3><ul><li><p>格式密钥（<strong>-----BEGIN CERTIFICATE-----格式密钥:</strong>——)</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>在PHP代码中是可以直接使用的,但是java代码中就不能直接使用,需要转换成pem的密钥文件.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>-----BEGIN RSA PRIVATE KEY-----格式:</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>RSA直接生成没有进行转换的密钥格式，公钥可以直接使用，私钥需要转换格式
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>-----BEGIN PRIVATE KEY-----格式:</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>上面的密钥PKCS#8格式化后的密钥格式,java中用的私钥一般就是这种格式,但是公钥就不需要转换,可以直接使用
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h2 id="格式之间的转换" tabindex="-1"><a class="header-anchor" href="#格式之间的转换" aria-hidden="true">#</a> 格式之间的转换</h2><ul><li><p><strong>BEGIN CERTIFICATE 转成 BEGIN PUBLIC KEY：</strong></p><p>对方给的cer格式的证书,需要转换之成java可以使用的PKCS#8格式密钥,具体如下</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    /**
     * BEGIN CERTIFICATE格式解析密钥
     * @Return: java.security.PublicKey
     */
    public static String getCerToPublicKey() throws FileNotFoundException, CertificateException {
        FileInputStream file = new FileInputStream(&quot;D://publicKey.cer&quot;);

        CertificateFactory ft = CertificateFactory.getInstance(&quot;X.509&quot;);
        X509Certificate certificate = (X509Certificate) ft.generateCertificate(file);
        PublicKey publicKey = certificate.getPublicKey();

        String strKey = &quot;-----BEGIN PUBLIC KEY-----\\n&quot; 
				        + Base64.encodeBase64String(publicKey.getEncoded()) 
				        + &quot;\\n-----END PUBLIC KEY-----&quot;;
		System.out.println(strKey);
        return strKey;
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>BEGIN RSA PRIVATE KEY 转成 BEGIN PRIVATE KEY：</strong></p><p>这两种格式之间的转换百度很多，这里就不写了，包括DER 转换 PEM格式都有，只是用工具进行转换； 贴个链接：https://www.jianshu.com/p/15d58b1ada5b</p></li></ul>`,22);function b(m,h){const s=i("ExternalLinkIcon");return r(),t("div",null,[p,o,e("p",null,[e("a",u,[a(".pfx 证书和 .cer 证书"),l(s)])]),v])}const g=n(c,[["render",b],["__file","PFX证书和CER证书.html.vue"]]);export{g as default};
