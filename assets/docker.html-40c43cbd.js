import{_ as e,p as i,q as l,a1 as r}from"./framework-449724a9.js";const a={},d=r(`<h1 id="docker" tabindex="-1"><a class="header-anchor" href="#docker" aria-hidden="true">#</a> docker</h1><blockquote><p>安装见: https://www.cnblogs.com/yufeng218/p/8370670.html 介绍：https://www.cnblogs.com/s-b-b/p/8533932.html</p></blockquote><h2 id="配置" tabindex="-1"><a class="header-anchor" href="#配置" aria-hidden="true">#</a> 配置</h2><h3 id="镜像加速" tabindex="-1"><a class="header-anchor" href="#镜像加速" aria-hidden="true">#</a> 镜像加速</h3><ul><li>/etc/docker/daemon.json（Linux）</li><li>%programdata%\\docker\\config\\daemon.json（Windows）</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{
  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="常用" tabindex="-1"><a class="header-anchor" href="#常用" aria-hidden="true">#</a> 常用</h2><ul><li>镜像操作 <ul><li>查看当前本地镜像列表: docker images</li><li>查看远程相关镜像镜像: docker search 镜像名称</li><li>拉取镜像到本地: docker pull xxx</li><li>删除镜像: docker rmi 镜像名字 <ul><li>当存在多个名字一样的镜像时候，可以通过指定tag方式来操作，如ubuntu:16.04</li></ul></li></ul></li><li>容器操作 <ul><li>创建一个docker容器，返回容器的id: docker create 镜像名字</li><li>运行docker容器：docker start</li><li>新建容器且运行，也就是上面两步一块执行: docker run 镜像名字 <ul><li>如果镜像不在，从源拉去</li><li>p：指定映射端口，如运行一个nginx服务，那么我可以设置 -p 8080:80来把本地的8080端口映射到容器里的80端口。</li><li>d：容器作为一个守护进程去进行运行，也就是保持后台运行，运行后会返回cotainer id。</li></ul></li><li>停止容器: docker stop 容器id</li><li>查看进程: docker ps <ul><li>docker ps -a</li></ul></li><li>查看容器配置 <ul><li>docker inspect id/name</li></ul></li><li>删除容器: docker rm 容器id</li></ul></li><li>容器与镜像间的操作 <ul><li>终端连接到容器: docker exec -i -t 容器id bash</li><li>复制文件到容器里面: docker cp index.html 镜像id://usr/share/nginx/html</li><li>保存更改并生成为一个新的image文件: docker commit -m &quot;mess&quot; 镜像id 镜像名字</li></ul></li><li>查看容器内的标准输出: docker logs <code>CONTAINER ID</code> / docker logs <code>NAMES</code><ul><li>docker logs -f id/name 类似tail -f</li></ul></li><li>停止容器: docker stop <code>CONTAINER ID</code> / docker stop <code>NAMES</code></li><li>查看命令帮助: docker command --help 如:docker status --help</li><li>docker pull training/webapp # 载入镜像</li><li>docker run -d -P training/webapp python app.py <ul><li>-d:让容器在后台运行。</li><li>-P:将容器内部使用的网络端口映射到我们使用的主机上。-p 8080:80来把本地的8080端口映射到容器里的80端口。</li></ul></li><li>docker run -d -p 5000:5000 training/webapp python app.py -p 设置端口映射</li><li>docker stop id/name</li><li>docker start id/name 重启</li><li>docker rm id/name 删除容器 <ul><li>删除容器时，容器必须是停止状态.</li></ul></li><li>查看端口映射: docker port id/name</li><li>查看容器进程: docker top id/name</li><li>查看容器底层信息: docker inspect id/name</li></ul><h2 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h2><h3 id="docker-hello-world" tabindex="-1"><a class="header-anchor" href="#docker-hello-world" aria-hidden="true">#</a> Docker Hello World</h3><ul><li>docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot; <ul><li>run:与前面的 docker 组合来运行一个容器。</li><li>ubuntu:15.10指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li><li>/bin/echo &quot;Hello world&quot;: 在启动的容器里执行的命令</li></ul></li></ul><h3 id="运行交互式的容器" tabindex="-1"><a class="header-anchor" href="#运行交互式的容器" aria-hidden="true">#</a> 运行交互式的容器</h3><ul><li>docker run -i -t ubuntu:15.10 /bin/bash <ul><li>-t:在新容器内指定一个伪终端或终端。</li><li>-i:允许你对容器内的标准输入 (STDIN) 进行交互。</li></ul></li></ul><h3 id="启动容器-后台模式" tabindex="-1"><a class="header-anchor" href="#启动容器-后台模式" aria-hidden="true">#</a> 启动容器（后台模式）</h3><ul><li>docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</li></ul><h2 id="容器" tabindex="-1"><a class="header-anchor" href="#容器" aria-hidden="true">#</a> 容器</h2><ul><li>docker pull training/webapp # 载入镜像</li><li>docker run -d -P training/webapp python app.py <ul><li>-d:让容器在后台运行。</li><li>-P:将容器内部使用的网络端口映射到我们使用的主机上。</li><li>docker run -d -p 5000:5000 training/webapp python app.py -p 设置端口映射</li></ul></li></ul><h2 id="镜像" tabindex="-1"><a class="header-anchor" href="#镜像" aria-hidden="true">#</a> 镜像</h2><ul><li><p>查看镜像: docker image</p><ul><li>REPOSITORY：表示镜像的仓库源</li><li>TAG：镜像的标签</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小</li></ul></li><li><p>获取镜像: docker pull ubuntu:13.10</p></li><li><p>查找镜像: docker search httpd</p></li><li><p>创建镜像:</p></li><li><p>设置镜像标签: docker tag 860c279d2fec runoob/centos:dev</p></li></ul><h2 id="docker网络" tabindex="-1"><a class="header-anchor" href="#docker网络" aria-hidden="true">#</a> Docker网络</h2><ul><li><p>单机网络</p><ul><li>Bridge Network</li><li>Host Network</li><li>None Network</li></ul></li><li><p>多机网络</p><ul><li>Overlay Network</li><li>安装插件: etcd</li></ul></li><li><p>docker network ls 查看网络</p></li><li><p>docker network create -h 查看帮助</p></li><li><p>docker network create -d bridge my-bridge 创建网络类型</p></li><li><p>docker run -d --name test3 --network my-bridge hello-world-loop</p></li><li><p>docker network connect -h</p></li><li><p>docker run -d --name test2 --link test hello-world-loop</p></li><li><p>测试</p><ul><li><p>docker run -d -p 5000:5000 --name test training/webapp python app.py</p></li><li><p>docker run -d -p 5001:5001 --name test2 --link test training/webapp python app.py</p></li><li><p>docker network create -d bridge my-bridge 创建网络</p></li><li><p>docker run -d -p 5003:5003 --network my-bridge --name test3 --link test training/webapp python app.py 指定网络</p></li><li><p>docker network connect my-bridge test 指定网络连接容器</p></li></ul></li></ul><h3 id="docker的镜像和容器" tabindex="-1"><a class="header-anchor" href="#docker的镜像和容器" aria-hidden="true">#</a> Docker的镜像和容器</h3><ul><li><p>docker 依赖的底层技术</p><ul><li>namespaces:访问隔离(pid,network,mnt)</li><li>cgroup:资源控制</li><li>ufs:文件系统隔离</li></ul></li><li><p>docker -o test.tar test 导出image</p></li><li><p>docker load -i test.tar 导入image</p></li><li><p>docker exec -it name bash 进入容器中</p></li><li><p>docker export containerid -o container.tar 导出容器</p></li><li><p>docker import container.tar xxxx/aaa 导入</p></li><li><p>资源监控</p><ul><li>docker stats id</li><li>docker inspect</li></ul></li></ul><h2 id="管理界面" tabindex="-1"><a class="header-anchor" href="#管理界面" aria-hidden="true">#</a> 管理界面</h2><blockquote><p>DockerUI: http://192.168.56.101:9000 Portainer: http://192.168.56.101:9001 admin/a**</p></blockquote><h3 id="dockerui" tabindex="-1"><a class="header-anchor" href="#dockerui" aria-hidden="true">#</a> DockerUI</h3><h4 id="安装" tabindex="-1"><a class="header-anchor" href="#安装" aria-hidden="true">#</a> 安装</h4><ul><li>拉取镜像: docker pull uifd/ui-for-docker</li><li>启动容器: docker run -it -d --name docker-web -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock docker.io/uifd/ui-for-docker</li><li>界面: ip:9000</li></ul><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4><blockquote><p>因为没有登录体系，所以很难在公司里流通。因为这样，每个人都可以去控制，即使通过TLS来控制权限，但无法将容器管理权限分配给某个用户，所以最终放弃该平台。</p></blockquote><ul><li><p>优点：</p><p>支持容器管理 支持镜像管理 基于docker api，自身也是一个容器。 稳定性高 可动态显示显示容器之间关系图 容器管理，增加端口映射，增加系统变量、映射目录等</p></li><li><p>缺点：</p><p>没有登录验证，因为没有登录体系，目前解决办法是，只开放本地访问，或者通过TLS来对权限进行控制。 无法分配某容器给某用户。 不支持多主机。 不支持集群swarm等 功能少 不支持控制台命令</p></li></ul><h3 id="shipyard" tabindex="-1"><a class="header-anchor" href="#shipyard" aria-hidden="true">#</a> Shipyard</h3><blockquote><p>打不开的，作者已经弃坑此项目: https://blog.hans362.cn/archives/266/</p></blockquote><h3 id="portainer" tabindex="-1"><a class="header-anchor" href="#portainer" aria-hidden="true">#</a> Portainer</h3><h4 id="安装-1" tabindex="-1"><a class="header-anchor" href="#安装-1" aria-hidden="true">#</a> 安装</h4><ul><li><p>拉取portainer镜像：</p><ul><li>docker pull docker.io/portainer/portainer</li></ul></li><li><p>镜像名打了tag：docker tag docker.io/portainer/portainer portainer</p></li><li><p>运行,映射端口到9001:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">9000</span>:9000 <span class="token parameter variable">--restart</span><span class="token operator">=</span>always <span class="token parameter variable">-v</span> /var/run/docker.sock:/var/run/docker.sock <span class="token parameter variable">--name</span> portainer portainer/portainer 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>打开浏览器: ip:9001</p></li></ul><blockquote><p>注： 　　如果出现创建用户／密码后，登录异常，查看服务器时间是否太过早（如果太早，则修改，则可以登录）</p></blockquote><h4 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1" aria-hidden="true">#</a> 总结</h4><ul><li><p>优点 支持容器管理、镜像管理 轻量级，消耗资源少 基于docker api，安全性高，可指定docker api端口，支持TLS证书认证。 支持权限分配 支持集群</p></li><li><p>缺点 功能不够强大。 容器创建后，无法通过后台增加端口。</p></li></ul>`,39),o=[d];function n(t,c){return i(),l("div",null,o)}const u=e(a,[["render",n],["__file","docker.html.vue"]]);export{u as default};
