import{_ as a,p as l,q as i,a1 as e}from"./framework-449724a9.js";const d={},r=e('<h1 id="_22-类加载器" tabindex="-1"><a class="header-anchor" href="#_22-类加载器" aria-hidden="true">#</a> 22 类加载器</h1><h2 id="_1-类的唯一性、命名空间" tabindex="-1"><a class="header-anchor" href="#_1-类的唯一性、命名空间" aria-hidden="true">#</a> 1 类的唯一性、命名空间</h2><ol><li><p>何为类的唯一性</p><p>同一Class文件，被同一虚拟机的同一类加载器加载</p></li><li><p>命名空间</p><p>每个类加载器都有自己命名空间</p><p>同一命名空间，不会出现类的完整名字(包含类的包名)相同的两个类</p><p>不同的命名空间中，有可能会出现完整名字相同的两个类</p></li></ol><h2 id="_2-类加载机制的基本特征" tabindex="-1"><a class="header-anchor" href="#_2-类加载机制的基本特征" aria-hidden="true">#</a> 2 类加载机制的基本特征</h2><ul><li>双亲委派模型，但不是所有类加载都遵守这个模型。</li><li>可见性，子类加载器可以访问父类加载器</li><li>单一性，由于父加载器的类型对子类加载器是可见的，父类加载的类，子类不允许再加载。</li></ul><h2 id="_3-引导类加载器" tabindex="-1"><a class="header-anchor" href="#_3-引导类加载器" aria-hidden="true">#</a> 3 引导类加载器</h2><p>启动类加载器（引导类加载器、Bootstrap ClassLoader)</p><ul><li>使用C/C++语言实现，嵌套在JVM内部</li><li>用于加载Java核心库（lib/rt.jar sum.boot.class.path路径下内容</li><li>出于安全考虑，Bootstrap启动类只加载包名为：java、javax、sun等开头的类</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li></ul><h2 id="_4-扩展类加载器" tabindex="-1"><a class="header-anchor" href="#_4-扩展类加载器" aria-hidden="true">#</a> 4 扩展类加载器</h2><ul><li>java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li><li>继承于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指向的目录中加载类库，或JDK安装目录jre/lib/ext子目录下加载类库</li></ul><h2 id="_5-应用程序类加载器-系统类加载器-appclassloader" tabindex="-1"><a class="header-anchor" href="#_5-应用程序类加载器-系统类加载器-appclassloader" aria-hidden="true">#</a> 5 应用程序类加载器(系统类加载器，AppClassLoader)</h2><ul><li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li><li>派生于ClassLoader类</li><li>负责加载环境变量classpath或系统属性java.class.path指定路径下类库</li></ul><h2 id="_6-用户自定义类加载器" tabindex="-1"><a class="header-anchor" href="#_6-用户自定义类加载器" aria-hidden="true">#</a> 6 用户自定义类加载器</h2><h2 id="_7-获取不同的类加载器" tabindex="-1"><a class="header-anchor" href="#_7-获取不同的类加载器" aria-hidden="true">#</a> 7 获取不同的类加载器</h2><ul><li><p>获得当前类的ClassLoader: <code>clazz.getClassLoader()</code></p></li><li><p>获得当前线程上下文的ClassLoader: <code>Thread.currentThread().getContextClassLoader()</code></p></li><li><p>获得系统的ClassLoader: <code>ClassLoader.getSystemClassLoader()</code></p></li></ul><h2 id="_8-双新委派" tabindex="-1"><a class="header-anchor" href="#_8-双新委派" aria-hidden="true">#</a> 8 双新委派</h2><p><code>loadClass</code> <code>findClass</code></p><p>加载类时，层层向上获取类的信息，如果上层没有，判断是否符合当前加载器的加载规则，如果不符合，层层向下指派加载。</p><ul><li>优势 <ul><li>避免类的重复加载，确保一个类的全局唯一性</li><li>保护程序安全，防止核心API被随意篡改 <ul><li>如：java.lang.String 只允许引导类加载器加载</li></ul></li></ul></li><li>弊端 <ul><li>检查类是否加载，是单向的，层层向上。上层类不知道下层的类加载。</li></ul></li><li>自定义类加载器 <ul><li>可以不使用双亲委派模式</li><li>不允许加载核心类，defineClass.preDefineClass 保护核心类库</li></ul></li></ul><h2 id="_9-破坏双亲委派机制" tabindex="-1"><a class="header-anchor" href="#_9-破坏双亲委派机制" aria-hidden="true">#</a> 9 破坏双亲委派机制</h2><h3 id="jdk1-2之前" tabindex="-1"><a class="header-anchor" href="#jdk1-2之前" aria-hidden="true">#</a> jdk1.2之前</h3><p>双亲委派模型在JDK1.2之后才被引入</p><h3 id="线程上下文类加载器" tabindex="-1"><a class="header-anchor" href="#线程上下文类加载器" aria-hidden="true">#</a> 线程上下文类加载器</h3><ul><li>SPI</li><li>线程上下文加载器</li></ul><h3 id="用户对程序动态性的追求-代码热替换、模块热部署" tabindex="-1"><a class="header-anchor" href="#用户对程序动态性的追求-代码热替换、模块热部署" aria-hidden="true">#</a> 用户对程序动态性的追求： 代码热替换、模块热部署</h3><h2 id="_10-沙箱安全机制" tabindex="-1"><a class="header-anchor" href="#_10-沙箱安全机制" aria-hidden="true">#</a> 10 沙箱安全机制</h2><ul><li>作用： <ul><li>保证程序安全</li><li>保护Java原生的JDK代码</li></ul></li></ul><h2 id="_11-自定义类加载器" tabindex="-1"><a class="header-anchor" href="#_11-自定义类加载器" aria-hidden="true">#</a> 11 自定义类加载器</h2><ul><li><p>为什么要自定义类加载器</p><ul><li>隔离加载类 <ul><li>Web应用服务器，jar冲突</li></ul></li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul></li><li><p>注意</p><ul><li>不同类加载器的对象类型转换会发生异常</li></ul></li><li><p>实现</p><ul><li>方式一：重写loadClass()方法 <ul><li>不推荐，避免打破双亲委派机制</li></ul></li><li>方式二：重写findClass()方法 <ul><li>推荐方法</li></ul></li></ul></li></ul><h2 id="_12-java9新特性" tabindex="-1"><a class="header-anchor" href="#_12-java9新特性" aria-hidden="true">#</a> 12 Java9新特性</h2><p>JMOD 模块化</p><ol><li>扩展机制被移除，扩展类加载器被保留，改名为平台类加载器PlatformClassLoader</li><li>平台类加载器、应用程序加载器，不再继承自java.net.URLClassLoader，而继承于BuiltinClassLoader</li><li>加载器有了名称，可以通过getName()方法获取。</li><li>类加载器双新委派机制变化 <ul><li>先判断归属某一模块，再判断该模块由哪个加载器加载</li></ul></li></ol>',32),s=[r];function h(n,t){return l(),i("div",null,s)}const u=a(d,[["render",h],["__file","22_类加载器.html.vue"]]);export{u as default};
